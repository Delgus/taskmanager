[![codecov](https://codecov.io/gh/Delgus/taskmanager/branch/master/graph/badge.svg)](https://codecov.io/gh/Delgus/taskmanager)

### TASK MANAGER
Вот сама задача:  
Реализовать систему очередей задач (библиотекой).  
Разруливать задачи должен TaskManager, задачи могут быть различных типов.  
У задач могут быть различные уровни приоритетов:

- 1 - очень низкий
- 2 - низкий
- 3 - средний
- 4 - высокий
- 5 - очень высокий

У задач есть события:

- Создание
- Выполнение
- Завершение
- Ошибка выполнения

На любое событие можно вешать от одного и более обработчиков, они должны выполняться по очередности FIFO.

Наличие тестов обязательное, и документирование в стиле godoc плюсом. Использовать готовые решения и библиотеки 
запрещено.

### Решение

##### EventDispatcher  
Для работы с событиями создадим структуру EventDispatcher. Она будет реализовывать EventDispatcherInterface.

##### Task
Создаем интерфейс который должна реализовывать задача - TaskInterface. 
Этот интерфейс будет реализовывать Task (одна задача)

##### TaskQueue
Это классическая очередь с прироритетом  
Реализуем очередь на основе binary heap. Можно воспользоваться стандартной библиотекой container/heap. Но она умеет 
слишком многое, а нам нужно релизовать лишь 2 - операции -> положить задачу в очередь, и получить из очереди. Для хранения
 задач используем слайс элементов (под капотом это классический массив).
 
 Возникшие трудности:
 
 > Разруливать задачи должен TaskManager

Не до конца ясно, что подразумевается под словом "разруливать",  TaskManager - должен выполнять задачи или нет?  
По мне более разумным кажется реализовать саму очередь и пул воркеров, которые обрабатывают задачи асинхронно.
Что из этих двух компонентов таск менеджер я не знаю. Поэтому реализовал отдельно очередь с приоритетом и назвал Queue и 
отдельно WorkerPool.

Чем я руководствовался? Есть очередь, в ней задачи. И мы просто выполняем их. При исполнении воркер ничего не должен 
знать о том какие события происходят для задачи. Он получил задачу и выполнил. Работу с событиями должен реализовывать 
сам Task. В задании даже написано черным по белому - `У задач есть события` То есть события есть у задач, очередь и воркер 
не должны ничего о них знать

 > У задач есть события:
 >  
 >  - Создание
 >  - Выполнение
 >  - Завершение
 >  - Ошибка выполнения

Что такое событие "Создание"? Разве это не тот момент, когда ты создаешь новую задачу? Но до того как ты создал новую
 задачу, новый объект или структуру (как вам удобнее называть) как ты прицепишь на нее обработчики? Нельзя повесить обработчики 
 на несозданный объект. Поэтому приходится везде явно вызывать EmitEvent(CreatedEvent)
